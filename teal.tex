

% ================================================================================
\section{Introduction}

Teal is a simplified language for teaching program analysis concepts.
Below, we describe the syntax, static semantics, dynamic semantics,
and the standard library.


%% % ================================================================================
%% \section{Running Teal}

%% % ================================================================================
%% \begin{TEALone}
%% \section{Teal Layers}

%%   TEAL has multiple layers

%% \begin{TEALtwo}
%%     foo
%% \end{TEALtwo}
%% \begin{TEALthree}
%%     bar
%% \end{TEALthree}

%% \end{TEALone}


% ================================================================================
\section{Syntax}
\[
  \begin{array}[t]{lcl@{\hspace{0.4cm}}l}
    \nta{Program} & \Prod & \ntstar{Module} \\
    \\
    \nta{Module} & \Prod & \ntstar{ImportDecl}\ \ntstar{Decl}\\
    \\
    \nta{ImportDecl} & \Prod & \vterminal{import}\ \nt{PackagePath}\ \vterminal{;}\\
    \\
    \nta{PackagePath} & \Prod & \terminal{id}\\
                    & \VB   & \nt{PackagePath}\ \vterminal{::}\ \terminal{id} \\
    \\
    \nta{Decl} & \Prod & \nt{VarDecl}\ \\
                 & \VB & \vterminal{fun}\ \terminal{id}\ \vterminal{(}\ \ntq{formals}\ \vterminal{)}\ \nt{optTyped}\ \vterminal{=}\ \nt{stmt}  & \astmap{Represented as } \ntaX{FunDecl} \\
    \\
    \nta{VarDecl} & \Prod & \vterminal{var}\ \terminal{id}\ \nt{optTyped} \\
                  & \VB   & \vterminal{var}\ \terminal{id}\ \nt{optTyped}\ \vterminal{:=}\ \nt{Expr} \vterminal{;}\\
    \\
    \nta{formals} & \Prod & \terminal{id}\ \nt{optTyped} & \astmap{Formals represented as \ntaX{VarDecl}s} \\
                  & \VB & \terminal{id}\ \nt{optTyped}\ \vterminal{,}\ \nt{formals}\\
                \\
    \nta{optTyped} & \Prod & \vterminal{:}\ \nt{Type}\\
                  & \VB{} & \varepsilon \\
    \\
    \nta{Type} & \Prod & \Cty{int}\ \VB\ \Cty{string}\ \VB\ \Cty{any} & \astmap{Represented as \ntaX{Int}, \ntaX{String}, \ntaX{Any}}\\
               & \VB   & \Cty{array}\ \Cty{[}\ \nt{Type}\ \Cty{]} & \astmap{Represented as \ntaX{Array}}\\
    \\
    \nta{BlockStmt} & \Prod & \vterminal{\{}\ \ntstar{Stmt}\ \vterminal{\}} \\
    \\
    \nta{Expr} & \Prod & \nt{Expr}\ \nt{binop}\ \nt{Expr} & \astmap{Represented as \ntaX{BinExpr}}\\
               & \VB   & \vterminal{not}\ \nt{Expr} & \astmap{Represented as \ntaX{NotExpr}}\\
               & \VB   & \vterminal{(}\ \nt{Expr}\ \nt{optTyped}\ \vterminal{)} & \astmap{Represented as \ntaX{TypedExpr}}\\
               & \VB   & \nt{Expr}\ \vterminal{[}\ \nt{Expr}\ \vterminal{]} & \astmap{Represented as \ntaX{IndexExpr}}\\
               & \VB   & \terminal{id}\ \vterminal{(}\ \ntq{actuals}\ \vterminal{)} & \astmap{Represented as \ntaX{CallExpr}}\\
               & \VB   & \vterminal{[}\ \ntq{actuals}\ \vterminal{]} & \astmap{Represented as \ntaX{ArrayLiteralExpr}}\\
               & \VB   & \vterminal{new}\ \nt{Type}\ \vterminal{(}\ \nt{Expr}\ \vterminal{)} & \astmap{Represented as \ntaX{NewExpr}}\\
               & \VB   & \terminal{int}\ \VB\ \terminal{string}\ \VB\ \vterminal{null} & \astmap{Represented as \ntaX{Constant}}\\
               & \VB   & \terminal{id} & \astmap{Represented as \ntaX{IdUse}}\\
    \\
    \nta{actuals} & \Prod & \nt{Expr} \\
                  & \VB   & \nt{Expr} \vterminal{,}\ \nt{actuals} \\
    \\
    \nta{binop} & \Prod &
		\vterminal{+}
                \ \VB\ \vterminal{-}
                \ \VB\ \vterminal{*}
                \ \VB\ \vterminal{/}
                \ \VB\ \vterminal{\%}\\
                & \VB& \vterminal{==}
                \ \VB\ \vterminal{!=}
                \ \VB\ \vterminal{$<$}
                \ \VB\ \vterminal{$<=$}
                \ \VB\ \vterminal{$>=$}
                \ \VB\ \vterminal{$>$}
                \\
                & \VB& \vterminal{or}
                \ \VB\ \vterminal{and}\\
    \\
    \nta{Stmt} & \Prod & \nt{VarDecl}  & \astmap{Represented as } \ntaX{VarDeclStmt}\\
               & \VB   & \nt{Expr}\ \vterminal{;} & \astmap{Represented as } \ntaX{ExprStmt}\\
               & \VB   & \nt{Expr}\ \vterminal{:=}\ \nt{Expr}\ \vterminal{;} & \astmap{Represented as } \ntaX{AssignStmt}\\
               & \VB   & \nt{BlockStmt} \\
               & \VB   & \vterminal{if}\ \nt{expr}\ \nt{block}\ \vterminal{else}\ \nt{block} & \astmap{Represented as } \ntaX{IfStmt}\\
               & \VB   & \vterminal{if}\ \nt{expr}\ \nt{block}\ & \astmap{Represented as \ntaX{IfStmt} with \ntaX{SkipStmt}} \\
               & \VB   & \vterminal{while}\ \nt{expr}\ \nt{block} & \astmap{Represented as } \ntaX{WhileStmt}\\
               & \VB   & \vterminal{return}\ \nt{expr}\ \vterminal{;} & \astmap{Represented as } \ntaX{ReturnStmt}\\
  \end{array}
\]

% ================================================================================
\section{Semantics and Failure}
The definitions of the static and dynamic semantics use a notion of
\emph{\failure{}}.  Failure in Teal means that compilation (statically)
or execution (dynamically) \emph{may} abort, and otherwise, program
semantics are undefined.

% ================================================================================
\section{Static Semantics}

Teal-0 enforces the following static constraints, and each violation of such a constraint is a \emph{static \failure}:
\begin{enumerate}

\item \textbf{Name analysis}: Teal-0 performs name analysis and enforces the following name-related constraints:
  \begin{enumerate}
    \item Each variable use binds to exactly one variable definition
    \item Each function use binds to exactly one function definition
    \item No variable is used within its defining module \emph{prior}
      to its declaration, where \emph{prior} refers to the pre-order
      traversal of the AST.
  \end{enumerate}

\item \textbf{No initialisation of module-level variables}:
  Syntactically, all variable declarations \code{\Ckw{var} x;} may contain an optional initialisation expression:
  \[
  \code{\Ckw{var} x := \nt{expr} ;}
    \]
    We statically disallow variable initialisations if this production
    is derived via
    $\nta{module}\rightarrow\nta{decl}\rightarrow\nta{vardecl}$.
    %% to prevent
    %% initialisation cycles that can otherwise happen if $\nt{expr}$
    %% depends on another module.
  \item All \terminal{int} literals $\ell$ are representable in the set of signed two's complement 64 bit integers $\mathbb{I}_{64}$
  \item All \terminal{string} literals are representable as Unicode character strings and do not contain supplementary \footnote{Characters encoded with more than 16 bits.} characters
  \item All assignments \vterminal{$e_1 := e_2$} subject $e_1$ to the \emph{lvalue restriction}, in that $e_1$ must be one of
    \begin{enumerate}
      \item \terminal{id}
      \item \vterminal{$e$[$e'$]}
    \end{enumerate}
\item (Teal-0 enforces no type checking constraints.)
\end{enumerate}

\subsection{Name Analysis}
\begin{enumerate}
  \item All names share the same scope:
    \begin{itemize}
    \item Variables
    \item Functions
    \end{itemize}
  \item The following are \emph{variable definitions}:
    \begin{enumerate}
    \item The following code fragments declare the underlined identifiers as variables that are visible to all sibling AST nodes and their descendants:
      \begin{enumerate}
      \item \code{\Ckw{import} \ldots::\ulm{x};}
      \item \code{\Ckw{var} \ulm{x} \ldots ;}
      \end{enumerate}
    \item The following code fragments declare the underlined identifiers as variables that are visible to all descendant AST nodes:
      \begin{enumerate}
      \item \code{\Ckw{fun} f (\ulm{x1}, \ldots, \ulm{xn}) \ldots }
      \end{enumerate}
    \end{enumerate}
  \item The following are \emph{function definitions}:
    \begin{enumerate}
    \item The following code fragments declare the underlined identifiers as functions that are visible to (a) the declaring AST node, (b) its sibling AST nodes, and (c) the descendants of (a) and (b):
      \begin{enumerate}
      \item \code{\Ckw{fun} \ulm{f} ({x1}, \ldots, {xn}) \ldots }
      \end{enumerate}
    \end{enumerate}
  \item Collectively, these \emph{definitions} are \emph{name definitions}:
    \begin{itemize}
    \item Variable definitions
    \item Function definitions
    \end{itemize}
  \item All other occurrences of identifiers are \emph{name uses} and bind to all declared identifiers with the same name:
    \begin{enumerate}
    \item \code{\ulm{f} (\ldots)} is a function use
    \item All other name uses are \emph{variable uses}
    \end{enumerate}
  \item For purposes of the dynamic semantics, each name definition introduces a globally unique name that we refer to as:
    \begin{itemize}
    \item \emph{Variable}, for variable definitions
    \item \emph{Function}, for function definitions
    \end{itemize}
\end{enumerate}

% ================================================================================
\section{Dynamic Semantics}

We define dynamic semantics largely informally.  In particular, we use
a notion of \emph{current state} $S$, which tracks input, output, and variable state:
\begin{enumerate}
\item Each variable \emph{may} be bound to a \emph{storage}
\item Each storage \emph{may} be bound to a single \emph{object}
\item $\textit{store}_S(x, o)$, where $x$ is a variable and $o$ an object in a current state $S$, yields a \emph{new} state $S'$ to which $S$ is the \emph{previous state} and $\tuple{x,o}$ is the \emph{state update}
\item In state $S$, $\textit{load}_S(x)$, where $x$ is a variable, yields the same result as $\textit{load}_{S'}(x)$ in the previous state $S'$, unless the state update to $S$ was $\tuple{x, o}$, in which case $\textit{load}_{S}(x)$ yields $o$
\item $\textit{load}_S(x)$ on a state $S$ that has no previous state yields $\Vnull$
\end{enumerate}
Note that our notion of \emph{current state} does not track fresh objects.


\subsection{Teal Objects}

\begin{enumerate}
\item Teal evaluation computes \emph{objects} (corresponding to \emph{values} in operational semantics)
%% \item Objects are \emph{transferred} whenever they are
%%   \begin{enumerate}
%%     \item Assigned to a variable
%%     \item Read from a variable
%%     \item Passed as actual parameter to a function call
%%     \item Returned as return value from a function call
%%   \end{enumerate}
\item Teal objects all have \emph{reference semantics}
\item Teal has the following built-in \emph{values}, which are \emph{immutable objects}:
  \begin{enumerate}
  \item The distinguished value \Vnull{}
  \item All 64 bit signed two's complement integer values (\emph{integers}), such as \Vint{0}, \Vint{1}, \ldots
  \item All Unicode character strings that do not contain supplementary characters (\emph{strings}), such as \Vstr{foo}, \Vstr{bar}, \ldots
  \end{enumerate}
\item Teal-0 has the following additional built-in objects:
\begin{enumerate}
\item \emph{Arrays}, which are mutable objects with the following properties:
  \begin{enumerate}
  \item A fixed (per object) nonnegative integer \emph{length}, \arraylength{\Varray}
  \item An index range \arrayindices{\Varray} = $\{i \in \mathbb{N} | 0 \le i < \arraylength{\Varray}\}$
  \item Mutable \emph{elements} $\Varray_i$ where $i \in \arrayindices{\Varray}$ that behave as \emph{variables}
  \end{enumerate}
\end{enumerate}
\end{enumerate}

\subsection{Teal Dynamic Types}
\begin{enumerate}
\item We define semantics with the help of \emph{dynamic types} that categorise Teal objects
\item We use notation $o : \Ttau$ to indicate that object $o$ has type $\Ttau$
\item We define the following dynamic types for objects $o$ in some state $S$:
  \begin{enumerate}
    \item $o : \TAny{}$
    \item $o : \TInt{} \iff o \textsf{ is an integer}$
    \item $o : \TString{} \iff o \textsf{ is a string}$
    \item $o : \TArrayof{\Ttau} \iff o \textsf{ is an array, and for all }i \in \arrayindices{o}, \textit{load}_S(\arrsub{o}{i}) : \Ttau$
    \item $o : \Ttau[\bot] \iff o : \Ttau \textsf{ or } o = \bot$
  \end{enumerate}
\end{enumerate}

\subsection{Teal Dynamic Equality}
\begin{enumerate}
\item Two teal objects $v_1$ and $v_2$ are \emph{Teal-equal} if any of the following hold:
  \begin{enumerate}
    \item $v_1$ and $v_2$ are both \Vnull
    \item $v_1 : \TInt$ and $v_2 : \TInt$ and $v_1 = v_2$
    \item $v_1 : \TString$ and $v_2 : \TString$ and $v_1 = v_2$
    \item $v_1$ and $v_2$ have the same \emph{identity}, according to their references
  \end{enumerate}
\end{enumerate}

\subsection{Expression Evaluation}\label{sec:eeval}
\begin{enumerate}
\item We write $\tuple{S,e} \downarrow \tuple{S',o}$ if expression $e$ in state $S$ evaluates to object $o$ and produces state $S'$
\item $e \downarrow o$ is short for $\tuple{S,e} \downarrow \tuple{S',o}$ and $S = S'$
\item For evaluating $e$ in state $S$ we consider the following cases:
  \begin{enumerate}
  \item \vterminal{$e_1 \odot e_2$}: $\tuple{S, e} \downarrow \tuple{S_2, v}$ where
    \begin{itemize}
      \item $\tuple{S, e_1} \downarrow \tuple{S_1, v_1}$
      \item $\tuple{S_1, e_2} \downarrow \tuple{S_2, v_2}$
      \item Consider the following cases for $\odot$:
        \begin{enumerate}
          \item $\odot = \vterminal{==}$: $v = \Vint{1}$ iff $v_1$ is \emph{Teal-equal} to $v_2$, otherwise $\Vint{0}$
          \item $\odot = \vterminal{!=}$: $v = \Vint{0}$ iff $v_1$ is \emph{Teal-equal} to $v_2$, otherwise $\Vint{1}$
          \item Otherwise, if not $v_1 : \TInt$ or not $v_2 : \TInt$, evaluation \fail{}s
          \item Otherwise consult the table below and \fail{} if the \textbf{Requirements} are not met:\\
            \begin{tabular}{|l|l|l|}
              \hline
              $\odot$ & \textbf{Requirement} & $v = $\\
              \hline
              \hline
              \vterminal{+}	& $v \in \mathbb{I}_{64}$			& $v_1 + v_2$ \\
              \hline
              \vterminal{-}	& $v \in \mathbb{I}_{64}$			& $v_1 - v_2$ \\
              \hline
              \vterminal{*}	& $v \in \mathbb{I}_{64}$			& $v_1 \times v_2$ \\
              \hline
              \vterminal{/}	& $v_2 \ne 0 \textsf{ and }v \in \mathbb{I}_{64}$		& $\frac{v_1}{v_2}$ \\
              \hline
              \vterminal{\%}	& $v_2 > 0 \textsf{ and }v \in \mathbb{I}_{64}$		& $v_1 \bmod v_2$ \\
              \hline
              \vterminal{$<$}	&&$ \Vint{1} \iff v_1 < v_2, \textsf{ otherwise } \Vint{0}$ \\
              \hline
              \vterminal{$<=$}	&&$ \Vint{1} \iff v_1 \le v_2, \textsf{ otherwise } \Vint{0}$ \\
              \hline
              \vterminal{$>=$}	&&$ \Vint{1} \iff v_1 \ge v_2, \textsf{ otherwise } \Vint{0}$ \\
              \hline
              \vterminal{$>$}	&&$ \Vint{1} \iff v_1 > v_2, \textsf{ otherwise } \Vint{0}$ \\
              \hline
              \vterminal{and}	&&$ \Vint{0} \iff v_1 = \Vint{0} \textsf{ or } \Vint{0} = v_2, \textsf{ otherwise } \Vint{1}$ \\
              \hline
              \vterminal{or}	&&$ \Vint{0} \iff v_1 = \Vint{0} = v_2, \textsf{ otherwise } \Vint{1}$ \\
              \hline
            \end{tabular}
        \end{enumerate}
      %% \item If $\
      %%   \begin{tabular}{lll}
      %%     \textbf{Requirements}
      %%   \end{tabular}
    \end{itemize}
  \item \vterminal{not $e'$}: Let $\tuple{S, e'} \downarrow \tuple{S', v}$, then
    \begin{itemize}
      \item $\tuple{S, e} \downarrow \tuple{S', \Vint{1}}$ iff v = \Vint{0}
      \item $\tuple{S, e} \downarrow \tuple{S', \Vint{0}}$ otherwise
    \end{itemize}
  \item \vterminal{$(e' : \Ttau)$}: same as $e'$
  \item \vterminal{$(e')$}: same as $e'$
  \item \vterminal{$e_1$ [$e_2$]}: Let
    \begin{itemize}
      \item $\tuple{S, e_1} \downarrow {S_1, a}$
      \item $\tuple{S_1, e_2} \downarrow {S_2, v}$, then:
      \item If not $a : \TArrayof{\tau_\bot}$: \failure
      \item If not $v : \TInt$: \failure
      \item If not $v \in \arrayindices{$a$}$: \failure
      \item Otherwise, $\tuple{S, e} \downarrow {S_2, \textit{load}_{S_2}(\arrsub{a}{v})}$
    \end{itemize}

  \item \vterminal{$f$ ($e_1$, \ldots, $e_k$)}: Informally:
    \begin{enumerate}
      \item Evaluation first evaluates arguments $e_1$ through $e_k$, including side effects
      \item Evaluation backs up all current local variable states in the current activation record
      \item Evaluation binds the results of the previous execution to the formal parameter variables of $f$, in the same order
      \item Evaluation executes the body of $f$ until it reaches a \vterminal{\Ckw{return} $e_r$} statement or the end of the function.
        \begin{itemize}
          \item If Evaluation reaches the end of the function, then this is equivalent to reaching \vterminal{\Ckw{return} null}.
        \end{itemize}
      \item At this point evaluation evaluates $e_r$, remembers it as $v_r$ restores the local variables stored in step $2$ above, and yields $v_r$.
    \end{enumerate}
  \item \vterminal{[$e_1$, \ldots, $e_k$]}: $\tuple{S,e} \downarrow \tuple{S'_k,o}$, where:
    \begin{enumerate}
      \item $S'_0 = S$
      \item $o : \TArrayof{\TAny}$ is a fresh array
      \item $\arraylength{o} = k$
      \item for all $i \in \arrayindices{o}$:
        \begin{itemize}
          \item $\tuple{S_{i-1},e_i} \downarrow \tuple{S_i, v_i}$
          \item $S'_i = \textit{store}_{S_i}(\arrsub{o}{i}, v_i)$
        \end{itemize}
    \end{enumerate}
  \item \vterminal{\Ckw{new} $\tau$ ($e'$)}:
    \begin{enumerate}
    \item If $\tau = \TArrayof{\tau'}$ for some $\tau'$ and $\tuple{S,e'} \downarrow \tuple{S',v}$ where $\ell : \TInt$ and $\ell \ge 0$, then $\tuple{S,e} \downarrow \tuple{S',o}$, where:
      \begin{itemize}
      \item $o : \TArrayof{\TAny}$ is a fresh array
      \item $\arraylength{o} = \ell$
      \end{itemize}
    \item Otherwise evaluation \fail{}s
    \end{enumerate}
  \item $\terminal{int}$:  $e \downarrow v$ where $v$ is the corresponding integer in \TInt
  \item $\terminal{string}$: $e \downarrow v$ where $v$ is the corresponding string in \TString{} (not including leading/trailing double quotes)
  \item $\vterminal{null}$: $e \downarrow \Vnull$
  \item $\terminal{id}$: let $x$ the variable assigned to $e$, then $e \downarrow \textit{load}_S(x)$
  \end{enumerate}
\end{enumerate}

\subsection{Statement Execution}
\begin{enumerate}
\item We write $\SEVAL{s}{S}{S'}$ if statement $s$ transforms state $S$ into state $S'$
\item For a given state $S$, we distinguish between statements $s$ (ignoring optional type annotations):
  \begin{enumerate}
    \item \vterminal{\Ckw{var} $x$ := $e$;}: Let $\tuple{S, e} \downarrow \tuple{S', o}$, then $\SEVAL{s}{S}{\textit{store}_{S'}(x, o)}$
    \item \vterminal{$e$;}: Let $\tuple{S, e} \downarrow \tuple{S', o}$, then $\SEVAL{s}{S}{S'}$
    \item \vterminal{$e_1$ := $e_2$;}: Let
      \begin{enumerate}
      \item $\tuple{S, e_2} \downarrow \tuple{S', o}$
      \item Distinguish $e_1$ as follows:
        \begin{enumerate}
          \item \textit{id}: then $\SEVAL{s}{S}{\textit{store}_{S'}(e_1, o)}$
          \item \vterminal{$e_3$[$e_4$]}: Let
            \begin{itemize}
            \item $\tuple{S', e_3} \downarrow {S_1, a}$
            \item $\tuple{S_1, e_4} \downarrow {S_2, v}$, then:
            \item If not $a : \TArrayof{\tau_\bot}$: \failure
            \item If not $v : \TInt$: \failure
            \item If not $v \in \arrayindices{$a$}$: \failure
            \item Otherwise, $\SEVAL{s}{S}{\textit{store}_{S_2}(a_v, o)}$
            \end{itemize}
        \end{enumerate}
      \end{enumerate}
    \item \vterminal{\{ $s_1$ \ldots $s_k$ \}}: $\SEVAL{s}{S}{S_k}$, where
      \begin{itemize}
        \item $S_0 = S$
        \item for all $i \in \{1, \ldots, k\}$: $\SEVAL{s_i}{S_{i-1}}{S_i}$
      \end{itemize}
    \item \vterminal{\Ckw{if} $e$ $s_1$ \Ckw{else} $s_2$}: Let $\tuple{S, e} \downarrow \tuple{S', o}$.
      \begin{enumerate}
        \item If $o = \Vint{0}$ then $\SEVAL{s}{S}{S_2}$, where $\SEVAL{s_2}{S'}{S_2}$
        \item Otherwise $\SEVAL{s}{S}{S_2}$, where $\SEVAL{s_1}{S'}{S_1}$
      \end{enumerate}
    \item \vterminal{\Ckw{if} $e$ $s_1$}: same as \vterminal{\Ckw{if} $e$ $s_1$ \Ckw{else} \{\}}
    \item \vterminal{\Ckw{while} $e$ $s'$}: Let $\tuple{S, e} \downarrow \tuple{S', o}$.
      \begin{enumerate}
        \item If $o = \Vint{0}$ then $\SEVAL{s}{S}{S'}$.
        \item Otherwise $\SEVAL{s}{S}{S_w}$, where $\SEVAL{\{ s'; s \}}{S'}{S_w}$
      \end{enumerate}
    \item \vterminal{\Ckw{return} $e$;}: See the evaluation of function calls in Section~\ref{eeval}.
  \end{enumerate}
\end{enumerate}


%% % ================================================================================
%% \section{Analysing the Teal AST}
%% In your programming assignments, we ask you to analyse Teal in various different ways.
%% This section describes how you can access the Teal AST

%% % ----------------------------------------
%% \subsection{AST JastAdd Attribute Interface}

%% % ================================================================================
%% \section{Teal Intermediate Representation}

%% % ================================================================================
%% \section{Analysing the Teal Intermediate Representation}
%% In your programming assignments, we ask you to analyse Teal in various different ways.
%% This section describes how you can access the Teal AST

%% % ----------------------------------------
%% \subsection{IR JastAdd Attribute Interface}

%% % ----------------------------------------
%% \subsection{IR Visitor Interface}

% ================================================================================

\section{Teal Standard Library}

Teal predefines a number of functions:

\begin{tabular}{|l|l|p{5cm}|}
  \hline
  \textbf{Builtin function name} & \textbf{Type or Type Scheme} & \textbf{Semantics} \\
  \hline
  \hline
    \texttt{\_\_builtin\_int\_add} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{+} \\
  \hline
    \texttt{\_\_builtin\_int\_sub} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{-} \\
  \hline
    \texttt{\_\_builtin\_int\_mul} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{*} \\
  \hline
    \texttt{\_\_builtin\_int\_div} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{/} \\
  \hline
    \texttt{\_\_builtin\_int\_mod} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{\%} \\
  \hline
    \texttt{\_\_builtin\_int\_eq} & $\forall \tyva. \tyva \times \tyva \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{==} \\
  \hline
    \texttt{\_\_builtin\_int\_neq} & $\forall \tyva. \tyva \times \tyva \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{!=} \\
  \hline
    \texttt{\_\_builtin\_int\_leq} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{$<$=} \\
  \hline
    \texttt{\_\_builtin\_int\_geq} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{$>$=} \\
  \hline
    \texttt{\_\_builtin\_int\_lt} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{$<$} \\
  \hline
    \texttt{\_\_builtin\_int\_gt} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{$>$} \\
  \hline
    \texttt{\_\_builtin\_int\_logical\_and} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{and} \\
  \hline
    \texttt{\_\_builtin\_int\_logical\_or} & $\TInt \times \TInt \to \TInt$ & Section~\ref{sec:eeval}: \vterminal{or} \\
  \hline
    \texttt{concat} & $\TString \times \TString \to \TString$ & Concatenates two strings \\
  \hline
    \texttt{print} & $\forall \tyva . \tyva \to \TAny$ & Prints out a string representation of its parameter \\
  \hline
    \texttt{read} & $() \to \TString$ & Reads a text line from the user \\
  \hline
    \texttt{string\_to\_int} & $\TString \to \TInt$ & $\TString$ to $\TInt$ conversion, or {\failure} if not possible \\
  \hline
    \texttt{int\_to\_string} & $\TInt \to \TString$ & Map $\TInt$ to string representation \\
  \hline
    \texttt{can\_convert\_to\_int} & $\TString \to \TInt$ & Yields \Vint{0} iff \texttt{string\_to\_int} would {\fail}, \Vint{1} otherwise \\
  \hline
    \texttt{array\_length} & $\forall \tyva . \TArrayof{\tyva} \to \TInt$ & maps $\Varray$ to $\arraylength{\Varray}$ \\
  \hline
\end{tabular}
