\chapter{Introduction}
\section{Introduction}

Static program analysis (\emph{static analysis} for short) is
\emph{``the art of reasoning about a program's behaviour without executing it''}~\cite{spa}.
It is an essential technique for improving the quality and reliability of software
systems and has been widely used in various applications such
as safety~\cite{cousot2005astree,Blanchet2002} and security~\cite{piskachev2021secucheck,flowDroid,ayewah2008using,Sayar_2022,fink2012wala},
performance optimisation~\cite{aho2007compilers,appel2004modern}, and software maintenance.
Static analysis aims to identify potential errors, bugs, or vulnerabilities
in a program before it is executed.
By examining the source code of a program, static
analysis can provide a detailed and precise understanding of its behaviour, including
its control flow~\cite{allen1970control}, dataflow~\cite{kam1977monotone},
and potential interactions with other system components.



One of the foundamental techniques used in static analysis is \emph{dataflow analysis},
which focuses on the flow of data through a program. Dataflow analysis applications are used to identify
potential sources of errors, such as uninitialised variables or null dereference~\cite{khedker2017data},
and to optimise the program's performance by identifying opportunities for
parallelisation or other forms of optimisation~\cite{aho2007compilers}.
Traditionally, dataflow analysis has been performed using imperative paradigms,
which are based on the idea of explicitly specifying \emph{how} the analysis should be
performed.
However, more recently, there has been a growing interest in using
declarative paradigms for dataflow analysis, which are based on specifying \emph{what}
the analysis should compute rather than \emph{how} it should be performed.
There are several declarative languages for specifying dataflow analysis, 
such as \emph{Flowspec}~\cite{smits2020flowspec}, which is a domain-specific language,
and Flix~\cite{madsen2016programming}. However, in this thesis, we focus on the utilisation of Reference 
Attribute Grammars~\cite{hedin2000rags} as a declarative approach for programming dataflow analysis. 
Our implementation is performed upon the \textsc{ExtendJ}~\cite{ekman2007jastadd} Java compiler
which is written in \textsc{JastAdd}~\cite{DBLP:journals/entcs/HedinM01}: a
meta-compilation system that supports RAGs.


Our focus is to create a novel framework that constructs control-flow graphs (CFGs), which represent the
sequence of executed instructions in a program, to perform dataflow analyses in a
more effective and efficient manner. This approach, combined with on-demand evaluation,
enables the execution of complex dataflow analysis in Integrated Development Environments,
improving the efficiency of the development process.

This thesis presents two main contributions.
\begin{itemize}
	\item In Paper~\ref{paper:intraj},  we describe \textsc{IntraCFG}, a language-agnostic framework for building
	precise, lightweight source-level CFGs. Unlike other frameworks that
	build CFGs on the intermediate representation level, \textsc{IntraCFG} superimposes
	CFGs on the program's abstract syntax tree (AST), allowing for more accurate
	analysis on the source code level and the construction of CFGs whose shape is not
	restricted to the AST structure. We demonstrate the effectiveness
	of \textsc{IntraCFG} through the implementation of \textsc{IntraJ}, a Java language
	instance. We show that \textsc{IntraJ} is as precise and efficient as existing
	static analysis tools. We also show the teaching potential of \textsc{IntraCFG}
	through the implementation of \textsc{IntraTeal}, a Teal instance,
	 a language designed for teaching \emph{Program Analysis} concepts.
	\item In Paper~\ref{paper:jfeature}, we introduce \textsc{JFeature}, a tool for automatically extracting and summarising
	the key features of a corpus (i.e., collection) of Java programs. \textsc{JFeature}
	allows researchers to understand the characteristics, e.g.,
	the use of different Java feature for different Java versions, of a codebase,
	which can be used to evaluate the effectiveness of their tools and techniques.
	In addition, in Paper~\ref{paper:jfeature}, we present a case study using \textsc{JFeature} to
	identify the key features of four popular open-source corpora, providing a
	baseline for future research.
\end{itemize}


