\part{Introduction}
\chapter{Introduction}
\section{Introduction}

Program Analysis is the branch of Computer Science that investigates the behaviour
and characteristics of a computer program. Program analysis applications are widely
used in numerous areas of Computer Science, including compiler construction,
e.g., to perform optimisations; software engineering, e.g., to detect bugs or
code smells; security and privacy, e.g., to detect vulnerabilities; safety
critical systems, e.g., avionic, automotive, and medical, to detect safety
violations, and many others.
We can distinguish between static and dynamic program analysis techniques.

Dynamic analysis involves executing the program under analysis and gathering
detailed information about its behaviour. Widely used dynamic analysis applications
are, for instance, tracing, profiling, and step-by-step debugging. More sophisticated dynamic
analysis techniques are based on symbolic execution, which consists in executing
the program under analysis with symbolic inputs and then solving the resulting
constraints to obtain concrete values for the program variables. Symbolic execution
is used, for instance, to detect buffer overflows, perform program verification,
and perform program synthesis.
Negatively, the properties verified using dynamic analysis techniques 
are dependent on the parameter used to execute the application. For example, if the
program under analysis is a web server, the properties verified by dynamic analysis
are dependent on the requests issued to the web server. Moreover, dynamic analysis
techniques are not able to detect properties that are not reachable, i.e., dead code.


Static program analysis is the practice of reasoning about a program's behaviour without executing it.
The analysis is performed by a static analysis tool,
which is a program that takes as input the source code of other programs and
generates a set of properties that hold for the program being analysed as output.
The properties verified by static analysis techniques are independent of the input
used to execute the program under analysis. Moreover, static analysis techniques can analyse unreachable code.
The main limitations of static analysis techniques are the results of the Turing and Rice undecidability
theorems, i.e., it is impossible to perform sound and complete static analysis of a program for non-trivial properties, e.g., 
we cannot always prove whether a program terminates or not. However, it is possible
to approximate the analyses introducing imprecision, e.g., adding a new possible answer
``I do not know'' to  ``It terminates'' or ``It does not terminate''. The introduction 
of imprecision is a trade-off between the precision of the analysis and the complexity
of the analysis. The more precise the analysis, the more complex it is. 
The more imprecise the analysis, the higher the probability of reporting 
false positives and false negatives to the user. 
% Discuss control flow graphs and dataflow analysis

Like any other software project, the development of a static analysis tool
it is a complex process that involves several steps, including the design of 
flexible and extensible architecture, i.e., a software architecture that is 
easy to extend and maintain. In this thesis, we employ the Declarative Programming
paradigm to overcome this issue. Declarative Programming is a programming 
paradigm that allows the programmer to specify what are the properties of a
program without specifying how to compute them (i.e., without specifying the 
algorithm). We used as declarative formalism an extension of Attribute Grammars. Attribute Grammars
were first introduced in 1968 by Donald Knuth and are a formalism for the specification
of the semantics of programming languages. Attribute Grammars are a generalisation
of Context-Free Grammars, which are a formalism for the specification of the syntax
of programming languages. 
Attribute grammars allow to decorate the nodes of an Abstract Syntax Tree (AST) with attributes. 
The attributes are computed by the attribute grammar rules, i.e., the values are specified
through equations. Reference Attribute Grammars extend Knuth's Attribute Grammars
with reference attributes whose values are references to other AST nodes. 
There are many implementations of Reference Attribute Grammars systems, including
the metacompiler and langauge JastAdd, used to implement large-scale compilers, such as,
ExtendJ and JModelica, and static analysis tools like the one described in this thesis.
Other famous implementations of Reference Attribute Grammars systems are Kiama and Silver, 
the latter being used to implement a C and Java compiler.

In this thesis we present a declarative and language independent framework for 
construcing control-flow graph on top of the AST.


This thesis will mainly focus on a class of static analysis techniques called
 control-flow and data-flow analysis. 


\subsection{Background}
Static analysis is a technique that allows to analyse the source code of a program
through an evaluation process based on the structure, on the form and the content
of the source code. 





\subsection{State-of-the-art}


\subsection{Reference Attribute Grammars}



