\chapter{Introduction}
\section{Introduction}

Static program analysis (\emph{static analysis} for short) is 
\emph{``the art of reasoning about a program's behaviour without executing it''}~\cite{spa}.
It is an essential tool for improving the quality and reliability of software
systems and has been widely used in various applications such
as safety~\cite{cousot2005astree,Blanchet2002} and security~\cite{piskachev2021secucheck,flowDroid,ayewah2008using,dura2021javadl,fink2012wala},
performance optimization~\cite{aho2007compilers,appel2004modern}, and software maintenance.
Static analysis aims to identify potential errors, bugs, or vulnerabilities
in a program before it is executed.
By examining the source code of a program, static program 
analysis can provide a detailed and precise understanding of its behaviour, including
its control flow~\cite{allen1970control}, dataflow~\cite{kam1977monotone}, 
and potential interactions with other system components.



One of the key techniques used in static analysis is \emph{dataflow analysis},
which focuses on the flow of data through a program. Dataflow analysis applications are used to identify
potential sources of errors, such as uninitialised variables or null pointers dereference~\cite{riouak2021precise,10.1016/j.scico.2012.02.002}, 
and to optimise the program's performance by identifying opportunities for 
parallelisation or other forms of optimisation~\cite{aho2007compilers}.
Traditionally, dataflow analysis has been performed using imperative paradigms, 
which are based on the idea of explicitly specifying \emph{how} the analysis should be 
performed. 
However, more recently, there has been a growing interest in using 
declarative paradigms for dataflow analysis, which are based on specifying \emph{what}
the analysis should compute rather than \emph{how} it should be performed.
In this Thesis, we will investigate the utilization of declarative paradigms in 
dataflow analysis~\cite{smits2020flowspec,madsen2016programming}. Our focus is to 
create a novel framework that constructs control-flow graphs (CFGs), which represent the 
sequence of executed instructions in a program, to perform dataflow analysis in a 
more effective and efficient manner. This approach enables execution of complex dataflow 
analysis in Integrated Development Environments, improving the efficiency of
the development process.

This Thesis presents two contributions.
Firstly, we introduce \textsc{IntraCFG}, a new and innovative framework for building
precise, lightweight source-level CFGs. Unlike other frameworks that 
build CFGs on the intermediate representation level, \textsc{IntraCFG} superimposes 
CFGs on the abstract syntax tree (AST) of the program, allowing for more accurate 
analysis on the source code level and the construction of CFGs whose shape is not 
restricted to the AST structure. We demonstrate the effectiveness
of \textsc{IntraCFG} through the implementation of \textsc{IntraJ}, a Java language
instance. We show that \textsc{IntraJ} is as precise and efficient as existing 
static analysis tools. We also show the teaching potential of \textsc{IntraCFG} 
through the implementation of \textsc{IntraTeal}, a TEAL instance, which
is a language designed for teaching programming concepts.
Secondly, we introduce \textsc{JFeature}, a tool for automatically extracting and summarising
the key features of a corpus (i.e., collection) of Java programs. \textsc{JFeature}
allows researchers to gain an understanding of the characteristics, for example,
use of different Java feature for different Java versions, of a codebase,
which can be used to evaluate the effectiveness of their tools and techniques.
In addition, in this paper, we present a case study of using \textsc{JFeature} to
identify the key features of four popular open-source corpora, providing a
baseline for future research.




% \subsection*{Thesis Contribution}

% The contributions of this thesis are summarised by the following two papers:

% \begin{itemize}
% 	\item \paperIref
% 	This paper presents a new framework for precise and light-weight construction of source-level control-flow 
% 	graphs, called \textsc{IntraCFG}. This framework is based on the idea of 
% 	representing a program's control flow at the source code level, instead of 
% 	the traditional intermediate representation level. This allows for more 
% 	precise analysis, as it captures the exact control flow of the original program.
%     We also implemented \textsc{IntraJ}, an instance of \textsc{IntraCFG} for the Java programming 
% 	language, and demonstrated its effectiveness (performance and precision) in 
% 	two study cases.

% 	\item \paperIIref
% 	This paper introduces \textsc{JFeature}, an extensible tool for automatically extracting and summarising
% 	the key features of a corpus (i.e., collection) of Java programs. \textsc{JFeature} 
% 	allows researchers to gain an understanding of the characteristics, for example,
% 	use of different Java feature for different Java versions, of a codebase, 
% 	which can be used to evaluate the effectiveness of their tools and techniques.
% 	In addition, in this paper, we present a case study of using \textsc{JFeature} to
% 	identify the key features of four popular open-source corpora, providing a
% 	baseline for future research.
% \end{itemize}


% Together, these contributions advance the state-of-the-art in program analysis 
% and software engineering, and provide practical tools for improving the development
% and maintenance of software systems.
