\section{Background}
\label{chap:attr-grammars}
\subsection{Attribute Grammars}
Attribute grammars~\cite{knuth1968semantics} (AGs) are a formalism for specifying
the syntax and semantics of programming languages.
They were first introduced by Knuth in 1968 as a way to define the syntax and semantics of the programming
language ALGOL 68. This formalism is based on the concept of attributes, 
which are properties associated with the elements of a language's abstract syntax tree.
Attribute grammars provide a powerful tool for specifying the behavior of a programming 
language and for verifying the correctness of programs written in that language.
%
AR are composed of two components: a context-free grammar, 
which defines the syntax of the language, and an attribute evaluation function, 
which defines the semantics of the language. The context-free grammar is used to 
parse a program into its abstract syntax tree, and the attribute evaluation function 
is used to compute the values of the attributes associated with each element 
of the tree.

A key advantage of attribute grammars is their ability to capture the 
interdependence of syntactic and semantic elements of a programming language. 
For example, the type of a variable may be determined by its declaration, 
but the type of an expression may be determined by the types of its subexpressions. 
Attribute grammars provide a precise and elegant way to specify these dependencies.

Moreover, AG, because of their intrinsic declarative nature, support modular specification.
Attribute grammars can be composed from smaller attribute grammars 
in a way that is similar to the composition of context-free grammars. This allows 
language and compiler designers to specify and verify the behavior of a language in a modular
and composable manner.

Attributes are define using equations. We can distinguish two types of attributes: synthesized attributes and inherited attributes.
For the sake of redability, we borrow the notation introduced in pattern, 
where attribute names are preceded by a symbol that indicates the type of the attribute.
We reserve the symbol \Abase{x} to denote the attribute name and the symbol $e$ to denote the attribute value,
e.g., a constant, a function of the node's children, or a function of the node's children 
and the node's own attributes. 


A synthesized attribute is a property of a language element that is computed 
based on the attributes of its subelements. For example, the type of an expression 
in a programming language may be a synthesized attribute that is computed based 
on the types of the subexpressions in the expression.

An inherited attribute is a property of a language element that is inherited from 
its parent element in the abstract syntax tree. For example, the scope of a variable 
in a programming language may be an inherited attribute that is inherited from the
scope in which the variable is declared.

One example of a synthesized attribute is the type of a variable in a programming language. 
The type of a variable may be determined based on the type of the expression that 
is used to initialize the variable. For example, if a variable is initialized
with the expression ``3 + 4'', the type of the variable would be determined to 
be integer based on the types of the operands in the expression.

One example of an inherited attribute is the scope of a variable in a programming 
language. The scope of a variable is the region of a program in which the variable 
is visible and can be accessed. The scope of a variable is inherited from the 
context in which it is declared. For example, if a variable is declared within a 
function, the variable will be visible and accessible within the body of the function, 
but not outside of the function.

\begin{equation*}
\Asyn{A}{x} = e
\end{equation*}
where \astnode{A} is the name of the node type.
Inherited attributes are defined by two parts: a declaration and an equation.
\begin{equation*}
\Ainh{A}{x} \quad\quad \quad\quad \Ainhdef{B}{*}{x} = e
\end{equation*}
where \astnode{A} and \astnode{B} are node types. 
The first part of the equation declares the attribute \Ainh{A}{x} as inherited by \astnode{A},
so that every node of type \astnode{A} has can access it. The second part of the 
equation defines the attribute for each child of \astnode{B}. The whildcard \astnode{*}
indicates that the attribute is defined and broadcasted to all children of \astnode{B} with type \astnode{A}.


\begin{figure}
    \begin{tikzpicture}[scale=0.7,edge from parent/.style={draw,-latex},sibling distance=8em,
      every node/.style = {align=center,scale=1},
      astnode/.style={shape=rectangle, draw, fill=white, minimum width=5mm,%
      minimum height=10mm},
      synthesized/.style={shape=rectangle, draw, fill=orange!15},
      inherited/.style={shape=rectangle, draw, fill=blue!15}
      ]
    
    \node [astnode,draw] (A) {\code{A}}
      child {node [astnode] (B) {\code{B}}}
      child {node [astnode] (C) {\code{C}}
    }
    ;
    \node [synthesized , draw, right=0pt of A] (AA) {\Asyn{A}{z} = \Asyn{B}{x} + 1 = 3};
    \node [synthesized , draw, left=0pt of B] (BB) {\Asyn{B}{x} = 2};
    \node [synthesized , draw, right=0pt of C] (CC) {\Asyn{C}{v} = 5};
    \node [inherited , draw, below right =0pt of C] (CC) {\Ainh{C}{y} = \Asyn{A}{z} + \Asyn{C}{v} = 8};
    
    \matrix [draw, below right = -50pt and -180pt,inner sep=1ex,cells={nodes={font=\sffamily,anchor=west}}] at (B) {
      \node [synthesized] {}; & \node{Synthesized attributes}; \\
      \node [inherited] {}; & \node{Inherited attributes}; \\
      \node [rectangle,draw] {}; & \node{AST Node}; \\
      \draw[-latex,dotted,color=black](0,0) -- ++ (0.3,0); & \node{Child relation}; \\
    };
    \end{tikzpicture}
    \caption{\label{fig:ragsExample} Graphical representation of the attribute grammar example.}
\end{figure}

Let us consider the following abstract grammar:

    \begin{align*}
        A& ::= B \quad C \\ 
        B& \\
        C&
    \end{align*}

and the following attribute declarations:
    \begin{align*}
        \Asyn{A}{z}& = \Asyn{B}{x} + 1 \\
        \Asyn{B}{x}& = 2 \\
        \Asyn{C}{v}& = 5 \\
        \Ainh{C}{y}& \\
        \Ainhdef{A}{C}{y}& = \Asyn{A}{z} + \Asyn{C}{v} \\
    \end{align*}
The value for the synthesized attribute \Asyn{A}{z} is computed by solving 
the equation systems for the attributes \Asyn{A}{z} and \Asyn{B}{x}:
\begin{align*}
    \Asyn{A}{z} &= \Asyn{B}{x} + 1 \\
    \Asyn{B}{x} &= 2
\end{align*}
leading to \Asyn{A}{z} = 3 and \Asyn{B}{x} = 2.
The value for the inherited attribute \Ainh{C}{y} is defined by the node \astnode{A} for
each child of type \astnode{C}. The value of \Ainh{C}{y} is computed by solving the equation system:
\begin{align*}
    \Ainh{C}{y} &= \Asyn{A}{z} + \Asyn{C}{v} \\
    \Asyn{C}{v} &= 5\\
    \Asyn{A}{z} &= 3
\end{align*}
resulting in \Ainh{C}{y} = 8. Figure~\ref{fig:ragsExample} depicts the described example.


\subsection{Reference Attribute Grammars}
\label{sec:rag}
Reference Attribute Grammars (RAGs) where introduced in~\cite{DBLP:journals/informaticaSI/Hedin00}
and are an extension of Attribute Grammars to Object-Oriented languages. While attributes in Attribute Grammars
can only refer to terminal values, RAGs allow attributes to refer to non-terminals i.e., node in the AST.
RAGs are well-suited for the analysis of object-oriented languages, since they enable 
the definition of relation between AST nodes. Attributes that refer to 
to AST nodes can declaratively construct relation, i.e., graphs, on the AST.
Examples of the relations that can be constructed using RAGs are:
\begin{itemize}
    \item Name analysis: checks that all names are well-defined and used correctly. A relation between 
    the name and the definition of the name is constructed,
    \item Type analysis: checks that all expressions have a valid type. A relation between the expression
    and its type is constructed,
    \item Graph of a class hierarchy: a graph where nodes are classes and edges are inheritance relations,
    \item Control flow graph: a graph where nodes are statements and/or expressions, and edges are control flow relations, and,
    \item Call graph: a graph where nodes are methods and edges are method calls.
\end{itemize}

\subsection{The JastAdd Metacompiler}
\label{sec:jastadd}
The JastAdd metacompiler~\cite{DBLP:journals/entcs/HedinM01} is a tool for the construction of
Reference Attribute Grammars. The JastAdd metacompiler is a Java-based tool that generates
Java code from a RAG. The generated code can be used to construct an AST and to perform
analysis on the AST.
The JastAdd metacompiler is based on the following components:
\begin{itemize}
    \item The JastAdd language: a language for the definition of RAGs. 
    The JastAdd language allow to specify the abstract grammar of a language, and,
    with a java-like syntax, the attributes of the RAG.
    \item The JastAdd compiler: a compiler that generates Java code from a RAG.
\end{itemize}
In JastAdd, synthesized attributs are defined using the \code{syn} keyword followed
by the type and the name of the attribute. Similarly, inherited attributes are defined
using the \code{inh} keyword. Let us reconsider the example depicted in Figure~\ref{fig:ragsExample}. 
The abstract grammar is defined in a \code{.ast} file with the following syntax:
    \begin{lstlisting}[language=JastAdd]
        A ::= B C;
        B; 
        C;
    \end{lstlisting}
where each line defines a non-terminal, i.e., a node in the AST.
The attributes are defined in a \code{.jrag} file with the following syntax:
    \begin{lstlisting}[language=JastAdd]
        syn int A.z() = B.x() + 1;
        syn int B.x() = 2;
        syn int C.v() = 5;
        inh int C.y();
        eq A.C.y() = A.z() + C.v();
    \end{lstlisting}
The last line is an equation that defines the value of the inherited attribute \Ainh{C}{y} for each child of type \astnode{C}.
\begin{figure}
    \begin{center}
        \begin{tikzpicture}
            \tikzstyle{block} = [rectangle, draw, text centered, minimum height=8em, minimum width=8em]
            \tikzstyle{line} = [draw, -latex]
            \node [block] (A) {
                \begin{lstlisting}[language=JastAdd]
aspect AttrDecl {
  syn int A.x() = 1;
  syn int B.x() = 2;
}
                \end{lstlisting}
            };
            \node [block, right=of A, yshift=5em] (B) {
                \begin{lstlisting}[language=JastAdd]
class A {
    public int x(){
    return 1;
    }
}
                \end{lstlisting}
            };
            \node [block, below=of B] (C) {
                \begin{lstlisting}[language=JastAdd]
class B {
    public int x(){
        return 2;
    }
}
                  \end{lstlisting}
             };
        
             \node (v1) at (-1.9,-0.05) {};
             \node (v2) at (2,-0.05) {};
             \node (v3) at (3.8,1.1) {};
             \node (v4) at (7.1,1.1) {};
             \node (v5) at (7.1,2.3) {};
             \node (v6) at (3.8,2.3) {};
             \node (v7) at (2,0.3) {};
             \node (v8) at (-1.9,0.3) {};
             \draw[opacity=0.2,fill=blue] (v1.center)--(v2.center)--(v3.center)--(v4.center)--(v5.center)--(v6.center)--(v7.center)--(v8.center)--(v1.center);
        
             \fill [opacity=0.2,blue]
                 (v1) \foreach \i in {2,...,8}{ -- (v\i) } -- cycle;
            
            \node (vv1) at (-1.9,-0.1) {};
            \node (vv2) at (2,-0.1) {};
            \node (vv3) at (3.8,-1.5) {};
            \node (vv4) at (7.1,-1.5) {};
            \node (vv5) at (7.1,-2.8) {};
            \node (vv6) at (3.8,-2.8) {};
            \node (vv7) at (2,-0.45) {};
            \node (vv8) at (-1.9,-0.45) {};
            \draw[opacity=0.2,fill=red] (vv1.center)--(vv2.center)--(vv3.center)--(vv4.center)--(vv5.center)--(vv6.center)--(vv7.center)--(vv8.center)--(vv1.center);
        
            \fill [opacity=0.2,red]
                (v1) \foreach \i in {2,...,8}{ -- (vv\i) } -- cycle;
        \end{tikzpicture}
    \end{center}
    \caption{\label{fig:interType} Example of intertype declaration.}
\end{figure}


JastAdd supports intertype declarations for the definition of attributes. An intertype declaration
of an attribute is a declaration that is performed into an aspect that, at compile time, 
is inlined in the class specified in the intertype declaration. The example in Figure~\ref{fig:interType}
shows an intertype declaration of an attribute. 
The attributes \Asyn{A}{x} and \Asyn{B}{x} are defined in the aspect \code{AttrDecl} 
that is inlined in the classes \code{A} and \code{B} respectively.

JastAdd supports not only synthesized and inherited attributes, but also:
\begin{itemize}
    \item \emph{Parametrised Attribute}: the value of the attribute might depend
    not only on the AST node itself, but also on the value of the arguments supplied
    to it. Attributes of this kind are widely used, especially in the definition of 
    type-checking rules.
    \begin{lstlisting}[language=JastAdd]
syn boolean Type.compatibleType(Type t){
    return this==t;
}
    \end{lstlisting}
    

    \item \emph{Higher-Order Attribute (HOA)}\footnote{Also known as \emph{Non-Terminal Attributes (NTA)}.}:
    the value of an HOA is a freshly new subtree. Are called \emph{Higher-Order Attributes}
    because are attribute and at the same time a non-terminal, therefore they can be attributed.
    The subtree computed by an HOA behaves like a normal non-terminal, i.e., it can be
    attributed and it can be used in the definition of other attributes. In JastAdd, HOAs
    are defined using the \code{nta} keyword. HOAs are widely used to reify information 
    that are not explicit in the source-code and therefore, not present in the AST.
    For example, when constructing a CFG of a method, is always useful to specify
    a unique entry point and a unique exit point for the method. In JastAdd, this can be
    achived using an HOA:
    \begin{lstlisting}[language=JastAdd]
syn nta Entry MethodDecl.entry() = new Entry();
syn nta Exit MethodDecl.exit() = new Exit();
    \end{lstlisting}
    We use the right-arrow symbol to denote HOAs, e.g.,  \Ahoa{MethodDecl}{entry} and \Ahoa{MethodDecl}{exit}.
    \item \emph{Circular Attribute}: an attribute which definition might depend direclty
    or indirectly on itself. In JastaAdd, circular attributes are expressed using the \code{circular}
    keyword. To guarantee termination, circular attributes are evaluated in a fixed-point
    computation, i.e., the attribute is evaluated until the value of the attribute does not change.
    The requirements, that are not checked by JastAdd, to guarantee termination are:
    \begin{itemize}
        \item All the possible values computed by the attribute must be placed 
        in a lattice of finite height.
        \item The intermediate results of the fix-point algorithm must increase 
        or decrease monotonically\footnote{In this Thesis, boolean circular attributes start
        as \emph{false} and monotonically grow with $\vee$, while set-typed circular attributes
        start as the empty set and monotonically grow with $\cup$.}. 
    \end{itemize}
    We use the symbol \AcircSyn{A}{x} to denote a circular synthesized attribute.

    \item \emph{Collection Attribute}: have no equations, but contributions. The
    result of a collection attribute is the aggreatation of contributions that can
    come frome anywhere else in the AST. A contribution clause is associated with
    an AST node type and describes information to be included in a collection
    attribute, possibly under certain conditions. Collection attributes, are expecially
    useful in compiler construction, to collect all the semantic errors in a program 
    from anywhere in the AST. In JastAdd, collection attributes are defined using the 
    \code{coll} keyword. For example, the following collection attribute collects all
    the type errors in a program:
    \begin{lstlisting}[language=JastAdd]
coll Set<Errors> Program.errors();
Expr contributes  when type.compatibleType(expectedType()) to Program.errors();
    \end{lstlisting}
    We use the following notation to denote the collection attribute \code{errors}: \Acoll{Program}{errors}.
\end{itemize}



