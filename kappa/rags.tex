\chapter{Attribute Grammars}
\label{chap:attr-grammars}
Attribute Grammars were first introduced in 1968 by Donald Knuth and are a formalism for the specification
of the semantics of programming languages. Attributes are used to decorate nodes of the AST
and are defeined by a pure function, i.e., side-effect free, that can access other attributes of the same node or of its children.
Attributes are define using equations. We can distinguish two types of attributes: synthesized attributes and inherited attributes.
For the sake of redability, we borrow the notation introduced in pattern, 
where attribute names are preceded by a symbol that indicates the type of the attribute.
We reserve the symbol \Abase{x} to denote the attribute name and the symbol $e$ to denote the attribute value,
e.g., a constant, a function of the node's children, or a function of the node's children 
and the node's own attributes. 

Synthesized attributes are defined by equations of the form:
\begin{equation*}
\Asyn{A}{x} = e
\end{equation*}
where \astnode{A} is the name of the node type.
Inherited attributes are defined by two parts: a declaration and an equation.
\begin{equation*}
\Ainh{A}{x} \quad\quad \quad\quad \Ainhdef{B}{*}{x} = e
\end{equation*}
where \astnode{A} and \astnode{B} are node types. 
The first part of the equation declares the attribute \Ainh{A}{x} as inherited by \astnode{A},
so that every node of type \astnode{A} has can access it. The second part of the 
equation defines the attribute for each child of \astnode{B}. The whildcard \astnode{*}
indicates that the attribute is defined and broadcasted to all children of \astnode{B} with type \astnode{A}.


\begin{figure}
    \begin{tikzpicture}[scale=0.7,edge from parent/.style={draw,-latex},sibling distance=8em,
      every node/.style = {align=center,scale=1},
      astnode/.style={shape=rectangle, draw, fill=white, minimum width=5mm,%
      minimum height=10mm},
      synthesized/.style={shape=rectangle, draw, fill=orange!15},
      inherited/.style={shape=rectangle, draw, fill=blue!15}
      ]
    
    \node [astnode,draw] (A) {\code{A}}
      child {node [astnode] (B) {\code{B}}}
      child {node [astnode] (C) {\code{C}}
    }
    ;
    \node [synthesized , draw, right=0pt of A] (AA) {\Asyn{A}{z} = \Asyn{B}{x} + 1 = 3};
    \node [synthesized , draw, left=0pt of B] (BB) {\Asyn{B}{x} = 2};
    \node [synthesized , draw, right=0pt of C] (CC) {\Asyn{C}{v} = 5};
    \node [inherited , draw, below right =0pt of C] (CC) {\Ainh{C}{y} = \Asyn{A}{z} + \Asyn{C}{v} = 8};
    
    \matrix [draw, below right = -50pt and -180pt,inner sep=1ex,cells={nodes={font=\sffamily,anchor=west}}] at (B) {
      \node [synthesized] {}; & \node{Synthesized attributes}; \\
      \node [inherited] {}; & \node{Inherited attributes}; \\
      \node [rectangle,draw] {}; & \node{AST Node}; \\
      \draw[-latex,dotted,color=black](0,0) -- ++ (0.3,0); & \node{Child relation}; \\
    };
    \end{tikzpicture}
    \caption{\label{fig:ragsExample} Graphical representation of the attribute grammar example.}
\end{figure}

Let us consider the following abstract grammar:

    \begin{align*}
        A& ::= B \quad C \\ 
        B& \\
        C&
    \end{align*}

and the following attribute declarations:
    \begin{align*}
        \Asyn{A}{z}& = \Asyn{B}{x} + 1 \\
        \Asyn{B}{x}& = 2 \\
        \Asyn{C}{v}& = 5 \\
        \Ainh{C}{y}& \\
        \Ainhdef{A}{C}{y}& = \Asyn{A}{z} + \Asyn{C}{v} \\
    \end{align*}
The value for the synthesized attribute \Asyn{A}{z} is computed by solving 
the equation systems for the attributes \Asyn{A}{z} and \Asyn{B}{x}:
\begin{align*}
    \Asyn{A}{z} &= \Asyn{B}{x} + 1 \\
    \Asyn{B}{x} &= 2
\end{align*}
leading to \Asyn{A}{z} = 3 and \Asyn{B}{x} = 2.
The value for the inherited attribute \Ainh{C}{y} is defined by the node \astnode{A} for
each child of type \astnode{C}. The value of \Ainh{C}{y} is computed by solving the equation system:
\begin{align*}
    \Ainh{C}{y} &= \Asyn{A}{z} + \Asyn{C}{v} \\
    \Asyn{C}{v} &= 5\\
    \Asyn{A}{z} &= 3
\end{align*}
resulting in \Ainh{C}{y} = 8. Figure~\ref{fig:ragsExample} depicts the described example.


\section{Reference Attribute Grammars}
\label{sec:rag}
Reference Attribute Grammars (RAGs) where introduced in~\cite{DBLP:journals/informaticaSI/Hedin00}
and are an extension of Attribute Grammars to Object-Oriented languages. While attributes in Attribute Grammars
can only refer to terminal values, RAGs allow attributes to refer to non-terminals i.e., node in the AST.
RAGs are well-suited for the analysis of object-oriented languages, since they enable 
the definition of relation between AST nodes. Attributes that refer to 
to AST nodes can declaratively construct relation, i.e., graphs, on the AST.
Examples of the relations that can be constructed using RAGs are:
\begin{itemize}
    \item Name analysis: checks that all names are well-defined and used correctly. A relation between 
    the name and the definition of the name is constructed,
    \item Type analysis: checks that all expressions have a valid type. A relation between the expression
    and its type is constructed,
    \item Graph of a class hierarchy: a graph where nodes are classes and edges are inheritance relations,
    \item Control flow graph: a graph where nodes are statements and/or expressions, and edges are control flow relations, and,
    \item Call graph: a graph where nodes are methods and edges are method calls.
\end{itemize}

\subsection{The JastAdd Metacompiler}
\label{sec:jastadd}
The JastAdd metacompiler~\cite{DBLP:journals/entcs/HedinM01} is a tool for the construction of
Reference Attribute Grammars. The JastAdd metacompiler is a Java-based tool that generates
Java code from a RAG. The generated code can be used to construct an AST and to perform
analysis on the AST.
The JastAdd metacompiler is based on the following components:
\begin{itemize}
    \item The JastAdd language: a language for the definition of RAGs. 
    The JastAdd language allow to specify the abstract grammar of a language, and,
    with a java-like syntax, the attributes of the RAG.
    \item The JastAdd compiler: a compiler that generates Java code from a RAG.
\end{itemize}
In JastAdd, synthesized attributs are defined using the \code{syn} keyword followed
by the type and the name of the attribute. Similarly, inherited attributes are defined
using the \code{inh} keyword. Let us reconsider the example depicted in Figure~\ref{fig:ragsExample}. 
The abstract grammar is defined in a \code{.ast} file with the following syntax:
    \begin{lstlisting}[language=JastAdd]
        A ::= B C;
        B; 
        C;
    \end{lstlisting}
where each line defines a non-terminal, i.e., a node in the AST.
The attributes are defined in a \code{.jrag} file with the following syntax:
    \begin{lstlisting}[language=JastAdd]
        syn int A.z() = B.x() + 1;
        syn int B.x() = 2;
        syn int C.v() = 5;
        inh int C.y();
        eq A.C.y() = A.z() + C.v();
    \end{lstlisting}
The last line is an equation that defines the value of the inherited attribute \Ainh{C}{y} for each child of type \astnode{C}.
\begin{figure}
    \begin{center}
        \begin{tikzpicture}
            \tikzstyle{block} = [rectangle, draw, text centered, minimum height=10em, minimum width=10em]
            \tikzstyle{line} = [draw, -latex]
            \node [block] (A) {
                \begin{lstlisting}[language=JastAdd]
aspect AttrDecl {
  syn int A.x() = 1;
  syn int B.x() = 2;
}
                \end{lstlisting}
            };
            \node [block, right=of A, yshift=5em] (B) {
                \begin{lstlisting}[language=JastAdd]
class A {
    public int x(){
    return 1;
    }
}
                \end{lstlisting}
            };
            \node [block, below=of B] (C) {
                \begin{lstlisting}[language=JastAdd]
class B {
    public int x(){
        return 2;
    }
}
                  \end{lstlisting}
             };
        
             \node (v1) at (-1.3,0) {};
             \node (v2) at (1.8,0) {};
             \node (v3) at (3.1,1.3) {};
             \node (v4) at (6.1,1.3) {};
             \node (v5) at (6.1,2.3) {};
             \node (v6) at (3.1,2.3) {};
             \node (v7) at (1.8,0.3) {};
             \node (v8) at (-1.3,0.3) {};
             \draw[opacity=0.2,fill=blue] (v1.center)--(v2.center)--(v3.center)--(v4.center)--(v5.center)--(v6.center)--(v7.center)--(v8.center)--(v1.center);
        
             \fill [opacity=0.2,blue]
                 (v1) \foreach \i in {2,...,8}{ -- (v\i) } -- cycle;
            
            \node (vv1) at (-1.3,-0.01) {};
            \node (vv2) at (1.8,-0.01) {};
            \node (vv3) at (3.1,-2.3) {};
            \node (vv4) at (6.1,-2.3) {};
            \node (vv5) at (6.1,-3.3) {};
            \node (vv6) at (3.1,-3.3) {};
            \node (vv7) at (1.8,-0.3) {};
            \node (vv8) at (-1.3,-0.3) {};
            \draw[opacity=0.2,fill=red] (vv1.center)--(vv2.center)--(vv3.center)--(vv4.center)--(vv5.center)--(vv6.center)--(vv7.center)--(vv8.center)--(vv1.center);
        
            \fill [opacity=0.2,red]
                (v1) \foreach \i in {2,...,8}{ -- (vv\i) } -- cycle;
        \end{tikzpicture}
    \end{center}
    \caption{\label{fig:interType} Example of intertype declaration.}
\end{figure}


JastAdd supports intertype declarations for the definition of attributes. An intertype declaration
of an attribute is a declaration that is performed into an aspect that, at compile time, 
is inlined in the class specified in the intertype declaration. The example in Figure~\ref{fig:interType}
shows an intertype declaration of an attribute. 
The attribtues \Asyn{A}{x} and \Asyn{B}{x} are defined in the aspect \code{AttrDecl} 
that is inlined in the classes \code{A} and \code{B} respectively.

JastAdd supports not only synthesized and inherited attributes, but also:
\begin{itemize}
    \item \emph{Parametrised Attribute}: the value of the attribute might depend
    not only on the AST node itself, but also on the value of the arguments supplied
    to it. Attributes of this kind are widely used, especially in the definition of 
    type-checking rules.
    \begin{lstlisting}[language=JastAdd]
        syn Type A.compatible(Type t) = this.type() == t;
    \end{lstlisting}
    

    \item \emph{Higher-Order Attribute (HOA)}\footnote{Also known as \emph{Non-Terminal Attributes (NTA)}.}:
    the value of an HOA is a freshly new subtree. Are called \emph{Higher-Order Attributes}
    because are attribute and at the same time a non-terminal, therefore they can be attributed.
    The subtree computed by an HOA behaves like a normal non-terminal, i.e., it can be
    attributed and it can be used in the definition of other attributes. In JastAdd, HOAs
    are defined using the \code{nta} keyword. HOAs are widely used to reify information 
    that are not explicit in the source-code and therefore, not present in the AST.
    For example, when constructing a CFG of a method, is always useful to specify
    a unique entry point and a unique exit point for the method. In JastAdd, this can be
    achived using an HOA:
    \begin{lstlisting}[language=JastAdd]
        syn nta Entry MethodDecl.entry() = new Entry();
        syn nta Exit MethodDecl.exit() = new Exit();
    \end{lstlisting}
    We use the right-arrow symbol to denote HOAs, e.g.,  \Ahoa{MethodDecl}{entry} and \Ahoa{MethodDecl}{exit}.
    \item \emph{Circular Attribute}: an attribute that which definition might depend direclty
    or indirectly on itself. In JastaAdd, circular attributes are expressed using the \code{circular}
    keyword. To guarantee termination, circular attributes are evaluated in a fixed-point
    computation, i.e., the attribute is evaluated until the value of the attribute does not change.
    The requirements, that are not checked by JastAdd, to guarantee termination are:
    \begin{itemize}
        \item All the possible values computed by the attribute must be placed 
        in a lattice of finite height.
        \item The 
    \end{itemize}

    \item \emph{Collection Attribute}: an attribute that returns a collection of values.
\end{itemize}



