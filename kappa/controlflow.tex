
\subsection{Control-Flow Analysis}
\label{sec:controlflow}
Control-Flow Analysis is a static analysis technique used to determin the control-flow graph (CFG) of a program.
The CFG is a directed graph representing all the possible path that a program can
take during its execution. The CFG of a program is used to perform many static analyses, such as
data-flow analysis, and to perform program transformations, e.g., loop unrolling.


Let us consider the graph $\mathcal{G}=(B,F)$ where $B$ is the set of nodes 
of the graph and $F$ is the set of edges. Each node $b$ of $B$ represents a
basic block of the program. A basic block is a sequence of instructions with one and only one
entry point and exit point. Meaning that there is no jump instruction in the middle of a basic block.
The edges of $F$ represent the possible transitions between basic blocks. Given two
basic blocks $b_1$ and $b_2$, there is an edge \CFGEdge{b_1}{b_2} in $F$ if $b_2$ is an immediate
successor of $b_1$.
\begin{definition}
    Given a basic block $b$, we define the set of successor of $b$ as 
    $$ \text{succ(b)} = \{b_2 \mid \CFGEdge{b}{b_2} \in F\}.$$
\end{definition}
The predecessor relation is defined in a similar way:
\begin{definition}
    Given a basic block $b$, we define the set of predecessor of $b$ as the 
    inverse of the successor relation:
    $$ \text{pred(b)} = \{b_1 \mid \CFGEdge{b_1}{b} \in F\} = \text{succ}^{-1}\text{(b)}.$$
\end{definition}
Among $B$, we can distinguish two special nodes: the entry node $b_{\text{entry}}$ and 
the exit node $b_{\text{exit}}$. The entry node is the node from which the program starts its execution.
The exit node is the node to which the program returns after its execution. The entry node is the only node
with no predecessor, and the exit node is the only node with no successor. More 
formally, we can define the entry node as the unique node $b_{\text{entry}}$ such that
$$ \forall b \in B, \text{pred}(b) \neq \emptyset \Rightarrow b = b_{\text{entry}}.$$
Similarly, we can define the exit node as the unique node $b_{\text{exit}}$ such that
$$ \forall b \in B, \text{succ}(b) \neq \emptyset \Rightarrow b = b_{\text{exit}}.$$
\begin{definition}
    A path in $\mathcal{G}$ is a sequence of basic blocks $b_1, \ldots, b_n$ such that
    $$ \forall i \in \{1, \ldots, n-1\},  b_{i+1} \in \text{succ}(b_i).$$
\end{definition}


Most of the time, the CFG is constructed on top of an intermediate representation
(IR) of the program. The IR is a language that is easier to analyze than the original
source language. The IR is usually a low-level language, such as LLVM IR or Java Bytecode, that are
closer to the machine code than the source language. 
Moreover, since the IR is usually targeted by serveral different langauges, 
it requires less engineering effort to implement a control-flow analysis for the IR than for each
source language.
A less common approach is to construct the CFG on top of the source language.
This method fits well for imperative languages, where the control-flow is 
explicit in the source code. For functional languages, the
control-flow is implicit in the source code, and the CFG is usually constructed
on top of the IR.




\subsection{Control-Flow Analysis Using RAGs}
\label{sec:cfarag}
In this section, we discuss \texttt{JastAddJ-Intraflow}, the first attempt of 
implementing control-flow analysis using RAGs.

Before discussing \texttt{JastAddJ-Intraflow}, we first introduce the 
\bnc\ language, a simple but powerful enough,  imperative language, that we 
will use to illustrate how JastAddJ-Intraflow works.


\subsection{The \bnc\ Language}
\bnc\ is a simple imperative language subset of the C language.
The syntax of \bnc\ is defined by the following abstract syntax:
\begin{lstlisting}[caption={Syntax of the \bnc\ language}]
Program ::= Stmt
Stmt ::= Block | IfStmt | WhileStmt | DeclStmt | AssignStmt
Block ::= Stmt*
IfStmt ::= Cond:Expr Then:Expr Else:Expr
WhileStmt ::= Cond:Expr Body:Expr
DeclStmt ::= Type id Init:Expr
AssignStmt ::= Dest:Expr Source:Expr
Expr ::= id | true | false | Not | And | Or
And ::= Left:Expr Right:Expr
Or ::= Left:Expr Right:Expr
Not ::= Expr
\end{lstlisting}
The starting symbol of the \bnc\ language is the \texttt{Program} non-terminal.
A \texttt{Program} is a list of \texttt{MethodDecl}s. A \texttt{MethodDecl} is a method
declaration, which is composed of a return type, a name, a list of parameters, and a body.
The body of a function is a \texttt{Block}, which is a list of statements. A \texttt{Block}
is a sequence of statements, which can be nested. The statements of SimpliC are
\texttt{IfStmt}, \texttt{WhileStmt}, \texttt{ReturnStmt}, \texttt{ExprStmt}, \texttt{DeclStmt},
and \texttt{AssignStmt}. Reguarding expressions, we decided to include only the most basic
expressions, such as variable reference (\texttt{Id}),  \texttt{Numeral}, boolean values (\texttt{true} and \texttt{false}),
and some binary operators (\texttt{Add}, \texttt{Less} and \texttt{Not}).
For the sake of simplicity, we did not include \texttt{BreakStmt} as the control-flow Analysis
solution is similar to the one of \texttt{ReturnStmt}. 

\subsection{JastAddJ-Intraflow}
\label{sec:jastaddj-intraflow}
The \texttt{JastAddJ-intraflow} (JJI) is the first framework designed for the construction of CFGs
using RAGs. It is not langauge agnostic as it targets the Java language.
JJI is built on top of an earlier version of the ExtendJ Java compiler, called \texttt{JastAddJ}.
The framework is built modularly for each Java version up to Java 7. 
The framework constructs the CFGs and exposes a set of APIs that can be used to 
traverse the CFGs. Listing \ref{lst:jastaddj-intraflow} shows the exposed APIs of JJI.
\begin{lstlisting}[caption={JastAddJ-Intraflow APIs}, label={lst:jastaddj-intraflow}, language=JastAdd]
    public Set<CFGNode> CFGNode.succ();
    public Set<CFGNode> CFGNode.pred();

    public CFGNode CFGNode.entry();
    public CFGNode CFGNode.exit();
\end{lstlisting}
JJI defines the \texttt{CFGNode} interface, which is the base interface for all the nodes in the CFG
and is implemented by all the expressions and statements AST nodes. Each node in the CFG has a set of
successors and a set of predecessors. The entry and exit methods return the reference to entry and exit point of
the enclosing method, respectively.
The possible root of a CFG in JJI is either a method declaration or a constructor declaration. 

The internal APIs of JJI are not intended to be used by the end-users and are used
to build the predecessor and successor sets of each node in the CFG.
The internal API
\begin{lstlisting}[caption={JastAddJ-Intraflow Internal APIs}, label={lst:jastaddj-intraflow-internal}, language=JastAdd]
   Set<CFGNode> CFGNode.following();

   Set<CFGNode> CFGNode.followingTrue();
   Set<CFGNode> CFGNode.followingFalse();
\end{lstlisting}
The \texttt{following} method returns the set of nodes that can be reached after
visiting the current node while the methods \texttt{followingTrue} and \texttt{followingFalse}
are used to model the conditional flow in branches, e.g., \texttt{IfStmt} and \texttt{WhileStmt}, but
also in short-circuiting operators, e.g., \texttt{\&\&} and \texttt{||} in Java.

In terms of RAGs, the framework is defined by the following attributes:
\begin{align*}
    &\Asyn{CFGNode}{succ} = \Asyn{CFGNode}{following} \\
    &\Ainh{CFGNode}{following}  \\
    &\Ainh{CFGNode}{followingTrue}  \\
    &\Ainh{CFGNode}{followingFalse}  \\
    &\Ahoa{CFGNode}{entry} = \text{\emph{fresh }} \astnode{Entry}\\
    &\Ahoa{CFGNode}{exit} = \text{\emph{fresh }} \astnode{Exit}
\end{align*}

The equations for the \texttt{following} attribute are defined based on the context 
of the node. For example, if we consider the \bnc\ language, the \code{Block} node
defines the inherited the attribute \Ainh{Stmt}{following} as follows, where $n$ is the
number of statements in the block:
\begin{align}
    \Ainhindex{Block}{getStmt}{int i}{following} = \begin{cases}
        \Ainh{Block}{following} & \text{if } i=n-1\\
        \{\astnode{Block}.\code{getStmt(i+1)}\} & \text{otherwise}
    \end{cases}
\end{align}
This equation defines the \texttt{following} attribute of the \texttt{Stmt} node 
depending on the position of the statement in the block. If the statement
is the last statement in the block, then the \texttt{following} attribute is
the set of nodes that can be reached after the block. Otherwise, the \texttt{following}
attribute is the set of nodes that can be reached after the next statement in the block.





A limitation of JJI is that allows only the construction of \emph{Parent-first} CFGs.
In a \emph{Parent-first} CFG, the parent node of a node $n$ is always visited before $n$, 
forcing the CFG to be constrained and tight to the AST structure.




